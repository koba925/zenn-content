---
title: "おわりに"
---

どうでしたでしょうか？

インクリメンタルに作っていくところを追体験するような感じで読めれば、と思ってこのスタイルに挑戦してみたのですが、完成形を見越してあらかじめ書いておかないと書き直しが増えることと、あまり先読みで書いてしまってはインクリメンタルな感じがでなくなりそうなのとでバランスが難しく感じていました。

なんとなくわかった気がした、ちょっといじってみよう、できそうな気がする、と思ってもらえれば望外の喜びです。

## ここから

すこしいじってみるとより理解が深まるでしょう。
minilangでやりやすそうな拡張としては以下のようなものが考えられます。

（簡単にできそうなことから）


* 入出力を充実させる
  改行しない版のprintを作ったりひとつのprintで複数の式を出力できるようにしたり
  キーボードからの入力を受け付けたり、ファイルに出力してみたり
* ファイルを読んで実行するようにする
  テストもファイルから実行して結果をチェックする形にできるかもしれません
* トップレベルからのreturnをエラーにする
　あまりそういう言語は見かけませんがプログラムからの返り値として扱うことも考えられます。どちらがよい仕様だと思いますか？
　OSが255までしか受け付けないからでしょうか。
* 関数呼び出しの引数の数が合わなければエラーにする[^js]
  [^js]: JavaScriptはエラーにしません。フリーダムな言語です。ほかにもあるかな？
　組み込み関数は？
* コメントを実装する
  Scannerでコメントを見つけたら読み飛ばすようにしてしまえばParser以降は影響を受けません。
  コメントをあらわす文字には"!"なんてどうでしょうか。
* 初期値を省略できるようにしてみましょう。
  nullがあればnullを入れるところですがないので省略したときの値には0を入れておきます。実行できてしまいます。
  仕様的にそれでいいのかっていう話はありますが構文解析の練習で。
* 真偽値や関数の計算をエラーにする
　比較はどうしますか？
  真偽値の+はor、*をandとして扱うのもありです。
* 比較演算子を追加する
  `<`、`>`はすぐできる
　2文字の演算子を追加したくなったらScannerを修正する必要があります
　`<`を見ただけではそれが`<`なのか、`<=`の1文字目なのかわからないので、
  もう1文字見てみる必要があります。
* 単項マイナスを実装する
* and, or 実装できるようになってます
  構文解析は左結合の二項演算子と同様ですが
  評価時にショートカットがあることに注意
* 三項演算子（`?:`）を実装する
  and, orと似てますが右結合であることに気を付けて。
* break文、continue文を実装する
  returnと同様な方法で実現可能です
* whileにthenを書けるようにする
  breakせずにwhileを終了したら、then以下を実行するようにします。
  pythonのwhile - elseと同じです[^while-else]
  [^while-else]: なんかあんまり評判がよくないんですが自分はけっこう好きです。フラグを付けて管理するよりはよっぽどいい。elseじゃなくてthenだったらそんなに不評にならなかったのではという気もする。英語話者ではないのでわかりませんが。
* `for`を実装する
  これも、文の先頭で`for`を見つけたら`while`の形に読み直してASTを作ればOKです。
  `for (;;)`はminilangの構文とはあんまり相性がよくないかも？
  `for a = 0; a # 5; a = a + 1 { print a; }`
  省略を許すとかいろいろやろうとするとその分複雑になります。
  シンタックスシュガー方式ではcontinueが作れない！
* null/Noneを作る
  minilangでは予約語のチェックみたいなことをしていないので、Scanner・Parserは修正するところはありません（変数と同じ扱いで十分）。
  Scannerで名前を読むところで、名前が"null"だったらPythonのNoneを返すようにします。
  Parser・Evaluatorで"null"を発見したら適宜処理。
  あとは表示とか（するなら）計算時の型チェックとかも
  変数初期化やreturnの値を省略したときの値としてnullを使いましょう。
  初期値を設定しないまま参照してしまったときにはエラーにしますか？nullが入っているものとして続行しますか？

ここまでやった

* 関数呼び出し時に余分な環境を作らない
  _eval_blockを呼び出す代わりに自前で文をevalしてやればできるはず。
* ペアを実装する
  配列でもあればいろいろとやる
  ペアを作ると楽しいかもしれません。
  ペアをつなげれば配列的なものも作れますので。 
* 配列を実装する
  AST自体が配列としてあらわされているので`["array", ...]`といきましょう。

  `set a[0] = 1;`などとして代入できるようにするには代入の左辺の処理が少々面倒かもしれません。
  `set a[b + 1][c[1]] = 1;`みたいなケースも処理できるようにしたくなりますし。
  まずは個々の要素の代入はおいておいて参照できるところから始め、
  次に`set_array(a, 0, 1);`などと組み込み関数で操作できるようにし、

* 文字列を実装する
  数はint、nullはNoneとPythonの型をそのまま使っていますので文字列もPythonの文字列をそのまま使う、
  といきたいところですが文字列は名前として使ってしまっていますのでminilangの文字列は
  `["string", <文字列>]`として区別がつくようにしましょう。
  Scannerで
  一貫性がありませんがしかたありません。
  MinilangStringみたいなクラスを作ってもいいと思います。
  set_char(a, 2, "b")


こじんまりまとまって頭に入ることを第一に考えた言語なので、
淡々といろんな機能を拡張していくには正直あまり向いてません。
主に、トークンを単なる文字列で、ASTをただの配列で表していることによるものです。
これは学習中にトークンやASTがどうなっているかを見るのには向いていますが、
いろんな機能を拡張していくのには向いていません。

ので、そこそこやってみたら少し本格的な本に進むのがおすすめです。

わかった気がしたら、一から自分で書いてみるのもおすすめです。
小さく作ったのはそういう意味もあります。
300行なら自分で書いてみるか、っていう気にもなりやすいかと。
私も何度か書いてみてやっと頭がすっきりした気がしました。
（逆に言えばそれまではすっきり理解できた気がしていなかった）
そのときのうれしさをほかのひとにも味わってもらえたら、というのがこの本を書いてみた動機のひとつとなっています。

ミュータブルな配列型や文字列型まで実装したくなったら、トークンやASTをクラスで書くようにして、一から書いてみるのがよいかと思います。

あるいはもっと本格的な言語処理系の勉強に進んでもスムーズに理解できるようになっていると思います。比較的簡単なインタプリタなら「ああここではあのへんの処理をやってるんだな」と理解しながら進めると思います。
もちろん新たに出てくる話もあるのでそのあたりは新たにお勉強です。

コンパイラは私もこれからお勉強です。

では、たのしい言語処理系ライフを！