---
title: "式"
---

## 足し算・引き算

では次に、足し算・引き算を作ってみましょう。
足し算は <数> + <数> という形ですが、複数つながることもできます。
そこで、足し算は`<数>`のあとに`+ <数>`が任意の数だけつながったものとします。
`+ <数>`が0個でもOKとしておくと都合がよいのでそうします。

ASTでは`["+", <数>, <数>]`という形とします。
`+ <数>` が2個以上続く場合、たとえば`1 + 2 + 3`は`["+", ["+", 1, 2], 3]`となるようにします。
これは、まず1と2を足して、その答えに3を足す、ということです。
足し算ではどう足しても答えは同じですが、引き算も同様です。



つながる場合があるのでループする

足し算・引き算はかけ算・割り算よりも優先順位が低いので、ひとつの式に足し算・引き算とかけ算・割り算があればかけ算、
`2 + 3 * 4` であれば`3 * 4`を先に計算してからその結果である12に2を足す、といった具合です。
ASTは`["+", 2, ["*", 3, 4]]`であるはずで

## かけ算・割り算


先にかけ算をして、次に足し算をします。
<足し算> は <かけ算> + <かけ算>
足し算は`<かけ算>`のあとに `+ <かけ算>`が任意の数だけつながったもの
かけ算は`<数>`のあとに`+ <数>`が任意の数だけつながったもの

## リファクタリング

ほぼ同じことを3回も書いているので[^tenuki]
左結合の二項演算子を処理するメソッド、という形でまとめます。

[^tenuki]: 等号が並んでもエラーにしなかったのは・・・

下位の要素を処理するメソッドを渡す必要がありますが、
`self._parse_add_sub`などと書けば関数として渡せます。

```py
    def _parse_equality(self):
        return self._parse_binary_op_left_assoc(("=", "#"), self._parse_add_sub)

    def _parse_binary_op_left_assoc(self, ops, sub_element):
        result = sub_element()
        while (op := self._current_token) in ops:
            self._next_token()
            result = [op, result, sub_element()]
        return result
```

あとEvaluatorもapplyとカブるところをうまくやりたいが軽く
applyが出てきてから考える？


## カッコ

カッコはいちばん優先度が高いので`_parse_primary`で処理します。
カッコの中は<式>がそのまま入りますので、素直に`_parse_expression()`を呼ぶだけです。
それだけ？
今`_parse_expression()`の中で式を処理してる途中なのに？とぐるぐる回ってしまう感じがするかもしれませんが、ちゃんとうまくいきます。
再帰楽しい！

## 累乗

右結合
かけ算ではどちらから計算しても答えに違いはありませんが、たとえば`24 / 4 / 2`を計算するときは

累乗では
2^3^4 は 256
